<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Chess Puzzle</title>
    <style>
        /* ========================================
           üé® VARI√ÅVEIS DE CORES (ALTERE AQUI!)
           ======================================== */
        :root {
            /* Cores do tabuleiro */
            --board-border-color: #000000;
            --board-background: rgb(31, 31, 36);
            --cell-light: #3b3b4d;
            --cell-dark: #1d1d30;
            --cell-visited: #000000;
            --cell-border: rgb(11, 11, 12);
            
            /* Cor do destaque (movimentos v√°lidos) */
            --highlight-color: rgba(255, 255, 255, 0);
            
            /* Cores dos elementos do jogo */
            --number-color: #ffffff;
            --blocked-color: rgba(255, 255, 255, 0.75);
            --knight-color: inherit;
            
            /* Cores de fundo da p√°gina */
            --background-gradient-start: #000;
            --background-gradient-end: #000000;
            
            /* Cores dos bot√µes */
            --button-primary: #667eea;
            --button-primary-hover: #5568d3;
            --button-secondary: #48bb78;
            --button-secondary-hover: #38a169;
            
            /* Cores dos modais */
            --modal-victory-color: #4CAF50;
            --modal-defeat-color: #f44336;
        }
        /* ======================================== */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: auto;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, var(--background-gradient-start) 0%, var(--background-gradient-end) 100%);
        }

        .container {
            border-radius: 15px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
            color: #555;
        }

        .board {
            display: grid;
            border: 3px solid var(--board-border-color);
            background-color: var(--board-background);
            gap: 15px;
            padding: 15px;
        }

        .cell {
            font-family: monospace;
            width: var(--cell-size, 60px);
            height: var(--cell-size, 60px);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            border: 3px solid var(--cell-border);
        }

        .cell.light {
            background-color: var(--cell-light);
        }

        .cell.dark {
            background-color: var(--cell-dark);
        }

        .cell.visited {
            background-color: var(--cell-visited) !important;
            color: #888;
        }

        .cell.highlight {
            box-shadow: inset 0 0 100px var(--highlight-color);
        }

        .cell:hover:not(.visited) {
            transform: scale(1.05);
            /* box-shadow: 0 0 15px rgba(0, 0, 0, 0.3); */
        }

        .cell .content {
            z-index: 1;
        }

        .cell .number {
            color: var(--number-color);
        }

        .cell .blocked {
            color: var(--blocked-color);
        }

        .knight {
            font-size: 40px;
            color: var(--knight-color);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .controls {
            text-align: center;
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            color: black;
            min-width: 120px;
            flex: 1;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            /* box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); */
        }

        button.primary {
            background: var(--button-primary);
        }
        button:hover {
            background: var(--button-primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.2);
        }

        button:active {
            transform: translateY(0);
        }
        button.secondary {
            background: var(--button-secondary);
        }

        button.secondary:hover {
            background: var(--button-secondary-hover);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.6);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s ease;
        }

        .modal button {
            color: black;
        }
        .modal button:hover {
            background: rgba(0, 0, 0, 0.1);
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 30px;
            border-radius: 15px;
            width: 80%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.4s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            margin-bottom: 15px;
            color: #333;
        }

        .modal-content.victory h2 {
            color: var(--modal-victory-color);
        }

        .modal-content.defeat h2 {
            color: var(--modal-defeat-color);
        }

        .modal-content p {
            margin-bottom: 20px;
            color: #666;
            font-size: 18px;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #555;
        }

        .legend-box {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            border-radius: 4px;
        }
        a {
            color: var(--button-primary)
        }
        a:hover {
            color: var(--button-primary-hover)
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="board" id="board"></div>
        <div class="controls">
            <a href="#" onclick="restartSameBoard()">Restart</a>
            <a href="#" onclick="resetGame()">New board</a>
            <a href="#" onclick="copyBoardCode()" title="Copy board code to share">Copy Code</a>
            <a href="#" onclick="() => {LOAD_BOARD = prompt('Paste Code here')}" title="Load board">Load Board</a>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content" id="modalContent">
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
            <button onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        document.querySelectorAll('a').forEach(elem => {
            elem.addEventListener('click', function(event) {
                event.preventDefault();
            });
        })
        // ========================================
        // üé® COLOR THEMES (Set your theme here!)
        // ========================================
        
        // ========================================
        // üì¶ LOAD BOARD FROM STRING (Optional)
        // ========================================
        // Format: [SIZE][THEME][BOARD_DATA]
        // SIZE: odd number (7, 9, 11, etc)
        // THEME: 3-letter code (ATH, GEP, etc)
        // BOARD_DATA: compressed board content
        //   '1' = number to collect
        //   'X' = blocked cell
        //   '0' = empty cell
        //   Numbers 2-9 = repeat previous character N times
        // Example: "7ATH100X31X20" = board 7x7, theme ATH, then pattern
        // Leave empty to generate random board
        var LOAD_BOARD = "";  // Example: "7ATH09090910907X03"
        
        // Select the theme using the 3-letter code (used when LOAD_BOARD is empty)
        const CURRENT_THEME = 'ATH'; 
        
        // Available themes library
        const THEMES = {
            // ATH Theme - Dark/Black
            'ATH': {
                name: 'Athom',
                boardBorderColor: '#000000',
                boardBackground: 'rgb(15, 15, 20)',
                cellLight: '#3b3b4d',
                cellDark: '#1d1d30',
                cellVisited: '#000000',
                cellBorder: 'rgb(11, 11, 12)',
                highlightColor: 'rgba(255, 255, 255, 0)',
                numberColor: 'rgba(255, 255, 255, 0.5)',
                blockedColor: 'rgba(255, 255, 255, 0.25)',
                knightColor: 'inherit',
                backgroundGradientStart: '#000',
                backgroundGradientEnd: '#000000',
                buttonPrimary: '#667eea',
                buttonPrimaryHover: '#5568d3',
                buttonSecondary: '#48bb78',
                buttonSecondaryHover: '#38a169',
                modalVictoryColor: '#4CAF50',
                modalDefeatColor: '#f44336'
            },
            
            // GEP Theme - Classic Chess
            'GEP': {
                name: 'Classic Chess',
                boardBorderColor: '#333',
                boardBackground: 'rgb(110, 98, 84)',
                cellLight: '#f0d9b5',
                cellDark: '#b58863',
                cellVisited: '#4a4a4a',
                cellBorder: 'rgba(0, 0, 0, 0.1)',
                highlightColor: 'rgba(0, 255, 0, 0)',
                numberColor: '#2196F3',
                blockedColor: '#f44336',
                knightColor: 'inherit',
                backgroundGradientStart: '#f0d9b5',
                backgroundGradientEnd: '#f0d9b5',
                buttonPrimary: '#667eea',
                buttonPrimaryHover: '#5568d3',
                buttonSecondary: '#48bb78',
                buttonSecondaryHover: '#38a169',
                modalVictoryColor: '#4CAF50',
                modalDefeatColor: '#f44336'
            }
        };
        
        // Apply selected theme to CSS variables
        function applyTheme(themeCode) {
            const theme = THEMES[themeCode];
            
            if (!theme) {
                return;
            }
            
            const root = document.documentElement;
            root.style.setProperty('--board-border-color', theme.boardBorderColor);
            root.style.setProperty('--board-background', theme.boardBackground);
            root.style.setProperty('--cell-light', theme.cellLight);
            root.style.setProperty('--cell-dark', theme.cellDark);
            root.style.setProperty('--cell-visited', theme.cellVisited);
            root.style.setProperty('--cell-border', theme.cellBorder);
            root.style.setProperty('--highlight-color', theme.highlightColor);
            root.style.setProperty('--number-color', theme.numberColor);
            root.style.setProperty('--blocked-color', theme.blockedColor);
            root.style.setProperty('--knight-color', theme.knightColor);
            root.style.setProperty('--background-gradient-start', theme.backgroundGradientStart);
            root.style.setProperty('--background-gradient-end', theme.backgroundGradientEnd);
            root.style.setProperty('--button-primary', theme.buttonPrimary);
            root.style.setProperty('--button-primary-hover', theme.buttonPrimaryHover);
            root.style.setProperty('--button-secondary', theme.buttonSecondary);
            root.style.setProperty('--button-secondary-hover', theme.buttonSecondaryHover);
            root.style.setProperty('--modal-victory-color', theme.modalVictoryColor);
            root.style.setProperty('--modal-defeat-color', theme.modalDefeatColor);
        }
        
        // Apply theme when page loads
        applyTheme(CURRENT_THEME);
        
        // üí° HOW TO ADD A NEW THEME:
        // 1. Copy one of the existing themes inside the THEMES object
        // 2. Rename the 3-letter code (ex: 'MYT')
        // 3. Change the desired colors
        // 4. Change the CURRENT_THEME variable to your theme code
        //
        // Available themes: ATH (Dark), GEP (Classic Chess)
        // ========================================
        
        // ========================================
        // üéÆ GAME SETTINGS (CHANGE HERE!)
        // ========================================
        const CONFIG = {
            // Board size (ex: 7 = 7x7, 9 = 9x9, 11 = 11x11)
            boardSize: 7,
            
            // Knight's starting position (to center use Math.floor(boardSize/2))
            // Row (0 = top, boardSize-1 = bottom)
            knightStartRow: 3,
            
            // Column (0 = left, boardSize-1 = right)
            knightStartCol: 3,
            
            // RANDOM quantity of numbers "1" to collect
            // The game will generate a random number between min and max
            numTargetsMin: 5,          // Minimum number of "1"s
            numTargetsMax: 20,         // Maximum number of "1"s

            // RANDOM quantity of "X" blocks
            // The game will generate a random number between min and max
            numBlocksMin: 5,           // Minimum number of "X" blocks
            numBlocksMax: 20,          // Maximum number of "X" blocks
            
            // Size of each cell in pixels
            cellSize: 50
        };
        
        // üí° TIP: For 9x9 board, use:
        //    boardSize: 9, knightStartRow: 4, knightStartCol: 4
        // üí° TIP: For fixed values (non-random), use the same value for min and max
        //    Ex: numTargetsMin: 5, numTargetsMax: 5 = always 5 numbers
        // üí° TIP: For 11x11 board, use:
        //    boardSize: 11, knightStartRow: 5, knightStartCol: 5
        // ========================================

        // Game variables
        let knightPosition = { row: CONFIG.knightStartRow, col: CONFIG.knightStartCol };
        let gameOver = false;
        let visitedCells = new Set();
        let numbersCollected = 0;

        // Valid knight moves (L-shape movement)
        const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
        ];

        // Apply dynamic styles based on settings
        function applyDynamicStyles() {
            const board = document.getElementById('board');
            const root = document.documentElement;
            
            // Apply CSS variable for cell size
            root.style.setProperty('--cell-size', CONFIG.cellSize + 'px');
            
            // Apply grid template
            board.style.gridTemplateColumns = `repeat(${CONFIG.boardSize}, ${CONFIG.cellSize}px)`;
            board.style.gridTemplateRows = `repeat(${CONFIG.boardSize}, ${CONFIG.cellSize}px)`;
        }

        // Automatic board generation
        let boardConfig = [];
        let totalNumbers = 0;

        // Helper function to generate random number between min and max (inclusive)
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Decode board from string format
        function decodeBoardString(boardString) {
            if (!boardString || boardString.length < 5) {
                return null;
            }

            // Extract size (first character(s) - odd numbers only)
            let sizeEndIndex = 0;
            while (sizeEndIndex < boardString.length && /\d/.test(boardString[sizeEndIndex])) {
                sizeEndIndex++;
            }
            
            const size = parseInt(boardString.substring(0, sizeEndIndex));
            
            // Validate size (must be odd)
            if (isNaN(size) || size % 2 === 0 || size < 3) {
                return null;
            }

            // Extract theme (next 3 characters)
            const themeCode = boardString.substring(sizeEndIndex, sizeEndIndex + 3).toUpperCase();
            if (!THEMES[themeCode]) {
                return null;
            }

            // Extract board data (remaining characters)
            const boardData = boardString.substring(sizeEndIndex + 3);
            
            // Decompress board data
            let expandedData = '';
            let lastChar = '0';
            
            for (let i = 0; i < boardData.length; i++) {
                const char = boardData[i];
                
                // Check if it's a repeat count (2-9)
                if (/[2-9]/.test(char)) {
                    const count = parseInt(char);
                    expandedData += lastChar.repeat(count - 1);
                } else {
                    expandedData += char;
                    lastChar = char;
                }
            }

            // Validate total cells
            const totalCells = size * size - 1; // -1 for knight position (center)
            if (expandedData.length !== totalCells) {
                return null;
            }

            // Create board array
            const board = Array(size).fill(0).map(() => Array(size).fill(0));
            const centerRow = Math.floor(size / 2);
            const centerCol = Math.floor(size / 2);
            
            let dataIndex = 0;
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    // Skip center position (knight's position)
                    if (row === centerRow && col === centerCol) {
                        continue;
                    }
                    
                    const cellValue = expandedData[dataIndex];
                    if (cellValue === '1') {
                        board[row][col] = '1';
                    } else if (cellValue === 'X' || cellValue === 'x') {
                        board[row][col] = 'X';
                    } else {
                        board[row][col] = 0;
                    }
                    dataIndex++;
                }
            }

            return { board, size, themeCode };
        }

        // Encode board to string format (for sharing)
        function encodeBoardString() {
            let result = `${CONFIG.boardSize}${CURRENT_THEME}`;
            
            const centerRow = Math.floor(CONFIG.boardSize / 2);
            const centerCol = Math.floor(CONFIG.boardSize / 2);
            
            let boardData = '';
            for (let row = 0; row < CONFIG.boardSize; row++) {
                for (let col = 0; col < CONFIG.boardSize; col++) {
                    if (row === centerRow && col === centerCol) {
                        continue; // Skip knight position
                    }
                    
                    const cell = boardConfig[row][col];
                    if (cell === '1') {
                        boardData += '1';
                    } else if (cell === 'X') {
                        boardData += 'X';
                    } else {
                        boardData += '0';
                    }
                }
            }
            
            // Compress consecutive characters
            let compressed = '';
            let currentChar = '';
            let count = 0;
            
            for (let i = 0; i < boardData.length; i++) {
                if (boardData[i] === currentChar) {
                    count++;
                    if (count === 9) {
                        compressed += '9';
                        count = 0;
                        currentChar = '';
                    }
                } else {
                    if (count > 1) {
                        compressed += count.toString();
                    }
                    compressed += boardData[i];
                    currentChar = boardData[i];
                    count = 1;
                }
            }
            
            if (count > 1) {
                compressed += count.toString();
            }
            
            result += compressed;
            return result;
        }

        // Check how many valid knight moves can reach a position
        function countAccessibleMoves(row, col, tempBoard) {
            let count = 0;
            
            for (let [dRow, dCol] of knightMoves) {
                const newRow = row + dRow;
                const newCol = col + dCol;
                
                // Check if position is within bounds
                if (newRow >= 0 && newRow < CONFIG.boardSize && 
                    newCol >= 0 && newCol < CONFIG.boardSize) {
                    // Check if it's not blocked
                    if (tempBoard[newRow][newCol] !== 'X') {
                        count++;
                    }
                }
            }
            
            return count;
        }

        // Validate that all "1"s have at least 2 accessible moves
        function validateBoard(tempBoard) {
            for (let row = 0; row < CONFIG.boardSize; row++) {
                for (let col = 0; col < CONFIG.boardSize; col++) {
                    if (tempBoard[row][col] === '1') {
                        const accessCount = countAccessibleMoves(row, col, tempBoard);
                        if (accessCount < 2) {
                            return false; // Invalid board - this "1" has less than 2 accesses
                        }
                    }
                }
            }
            return true; // All "1"s have at least 2 accesses
        }

        function generateBoard() {
            const maxAttempts = 100; // Prevent infinite loop
            let attempts = 0;
            let validBoard = false;
            
            while (!validBoard && attempts < maxAttempts) {
                attempts++;
                
                // Create empty board
                boardConfig = Array(CONFIG.boardSize).fill(0).map(() => Array(CONFIG.boardSize).fill(0));
                
                // Ensure knight's starting position stays empty
                const centerRow = CONFIG.knightStartRow;
                const centerCol = CONFIG.knightStartCol;
                
                // Generate random quantity of elements
                const numOnes = getRandomInt(CONFIG.numTargetsMin, CONFIG.numTargetsMax);
                const numBlocks = getRandomInt(CONFIG.numBlocksMin, CONFIG.numBlocksMax);
                
                // Helper function to get valid random positions
                function getRandomPosition() {
                    let row, col;
                    do {
                        row = Math.floor(Math.random() * CONFIG.boardSize);
                        col = Math.floor(Math.random() * CONFIG.boardSize);
                    } while ((row === centerRow && col === centerCol) || boardConfig[row][col] !== 0);
                    return { row, col };
                }
                
                // Add numbers "1"
                for (let i = 0; i < numOnes; i++) {
                    const { row, col } = getRandomPosition();
                    boardConfig[row][col] = '1';
                }
                
                // Add "X" blocks
                for (let i = 0; i < numBlocks; i++) {
                    const { row, col } = getRandomPosition();
                    boardConfig[row][col] = 'X';
                }
                
                // Validate board
                validBoard = validateBoard(boardConfig);
            }
            
            if (!validBoard) {
                console.warn(`Could not generate valid board after ${maxAttempts} attempts. Using last attempt.`);
            } else if (attempts > 1) {
                console.log(`Valid board generated after ${attempts} attempt(s)`);
            }
            
            // Count total numbers
            totalNumbers = 0;
            boardConfig.forEach(row => {
                row.forEach(cell => {
                    if (cell === '1') totalNumbers++;
                });
            });
        }

        // Render the board
        function renderBoard() {
            // Apply dynamic styles
            applyDynamicStyles();
            
            const board = document.getElementById('board');
            board.innerHTML = '';
            visitedCells.clear();
            numbersCollected = 0;
            gameOver = false;
            
            // Mark starting position as visited
            visitedCells.add(`${knightPosition.row}-${knightPosition.col}`);
            
            const currentBoardSize = CONFIG.boardSize;
            for (let row = 0; row < currentBoardSize; row++) {
                for (let col = 0; col < currentBoardSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.className += (row + col) % 2 === 0 ? ' light' : ' dark';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    const content = document.createElement('span');
                    content.className = 'content';
                    
                    // Add cell content
                    if (row === knightPosition.row && col === knightPosition.col) {
                        content.textContent = '‚ôû';
                        content.className += ' knight';
                        cell.classList.add('visited');
                    } else if (boardConfig[row][col] === '1') {
                        content.textContent = '1';
                        content.className += ' number';
                    } else if (boardConfig[row][col] === 'X') {
                        content.textContent = 'X';
                        content.className += ' blocked';
                    }
                    
                    cell.appendChild(content);
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    board.appendChild(cell);
                }
            }
            
            // updateInfo();
            highlightValidMoves();
        }

        // Initialize board (generates new and renders)
        function initBoard() {
            // Try to load board from string
            if (LOAD_BOARD && LOAD_BOARD.trim() !== '') {
                const decoded = decodeBoardString(LOAD_BOARD);
                if (decoded) {
                    // Update CONFIG with loaded values
                    CONFIG.boardSize = decoded.size;
                    CONFIG.knightStartRow = Math.floor(decoded.size / 2);
                    CONFIG.knightStartCol = Math.floor(decoded.size / 2);
                    
                    // Apply loaded theme
                    applyTheme(decoded.themeCode);
                    
                    // Set board config
                    boardConfig = decoded.board;
                    
                    // Count total numbers
                    totalNumbers = 0;
                    boardConfig.forEach(row => {
                        row.forEach(cell => {
                            if (cell === '1') totalNumbers++;
                        });
                    });
                    
                    // Reset knight position
                    knightPosition = { row: CONFIG.knightStartRow, col: CONFIG.knightStartCol };
                    
                    renderBoard();
                    return;
                }
            }
            
            // Generate random board if no valid load string
            generateBoard();
            renderBoard();
            
            // Auto-generate board code for sharing
            encodeBoardString();
        }

        // Highlight valid moves
        function highlightValidMoves() {
            // Remove previous highlights
            document.querySelectorAll('.cell.highlight').forEach(cell => {
                cell.classList.remove('highlight');
            });
            
            if (gameOver) return;
            
            // Add highlight to valid moves
            knightMoves.forEach(([dRow, dCol]) => {
                const newRow = knightPosition.row + dRow;
                const newCol = knightPosition.col + dCol;
                
                if (isValidMove(newRow, newCol)) {
                    const cell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                    if (cell && !cell.classList.contains('visited')) {
                        cell.classList.add('highlight');
                    }
                }
            });
        }

        // Check if move is valid
        function isValidMove(row, col) {
            const currentBoardSize = CONFIG.boardSize;
            if (row < 0 || row >= currentBoardSize || col < 0 || col >= currentBoardSize) {
                return false;
            }
            
            const dRow = Math.abs(row - knightPosition.row);
            const dCol = Math.abs(col - knightPosition.col);
            
            // Check if it's a valid L-shaped move
            return (dRow === 2 && dCol === 1) || (dRow === 1 && dCol === 2);
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (gameOver) return;
            
            if (!isValidMove(row, col)) {
                return; // Invalid move, just ignore
            }
            
            const cellKey = `${row}-${col}`;
            
            // Check if already visited
            if (visitedCells.has(cellKey)) {
                endGame(false, 'Game over');
                return;
            }
            
            // Check if it's a blocked cell
            if (boardConfig[row][col] === 'X') {
                endGame(false, 'Game over');
                return;
            }
            
            // Valid move
            moveKnight(row, col);
            
            // Check if collected a number
            if (boardConfig[row][col] === '1') {
                numbersCollected++;
                // updateInfo();
                
                // Check victory
                if (numbersCollected === totalNumbers) {
                    endGame(true, 'Game over');
                }
            }
        }

        // Move the knight
        function moveKnight(row, col) {
            // Remove knight from old position
            const oldCell = document.querySelector(`[data-row="${knightPosition.row}"][data-col="${knightPosition.col}"]`);
            oldCell.querySelector('.content').textContent = boardConfig[knightPosition.row][knightPosition.col] || '';
            oldCell.querySelector('.content').className = 'content';
            
            // Update position
            knightPosition = { row, col };
            visitedCells.add(`${row}-${col}`);
            
            // Add knight to new position
            const newCell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            newCell.querySelector('.content').textContent = '‚ôû';
            newCell.querySelector('.content').className = 'content knight';
            newCell.classList.add('visited');
            
            highlightValidMoves();
        }

        // Update information
        // function updateInfo() {
        //     document.getElementById('collected').textContent = numbersCollected;
        //     document.getElementById('total').textContent = totalNumbers;
        // }

        // End game
        function endGame(victory, message) {
            gameOver = true;
            const modal = document.getElementById('modal');
            const modalContent = document.getElementById('modalContent');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            
            modalContent.className = 'modal-content ' + (victory ? 'victory' : 'defeat');
            modalTitle.textContent = victory ? 'üéâ Victory!' : '‚ùå Defeat!';
            modalMessage.textContent = message;
            modal.style.display = 'block';
        }

        // Close modal
        function closeModal() {
            document.getElementById('modal').style.display = 'none';
        }

        // Restart with same board
        function restartSameBoard() {
            knightPosition = { row: CONFIG.knightStartRow, col: CONFIG.knightStartCol };
            closeModal();
            renderBoard();
        }

        // Reset game with new board
        function resetGame() {
            knightPosition = { row: CONFIG.knightStartRow, col: CONFIG.knightStartCol };
            closeModal();
            initBoard();
        }

        // Copy board code to clipboard
        function copyBoardCode() {
            const code = encodeBoardString();
            
            // Try to copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(code).then(() => {
                    alert(`‚úÖ Board code copied to clipboard!\n\n${code}\n\nShare this code with others to play the same board.`);
                }).catch(err => {
                    prompt('Copy this board code:', code);
                });
            } else {
                // Fallback for older browsers
                prompt('Copy this board code:', code);
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('modal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Initialize the game
        initBoard();
    </script>
</body>
</html>

